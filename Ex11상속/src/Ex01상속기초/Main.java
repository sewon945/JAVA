package Ex01상속기초;

public class Main {

	public static void main(String[] args) {

		// 1. Parents 자료형 p 라고 하는 객체 생성
		Parents  p = new Parents();
		
		// 2. Child 자료형 c 객체 생성
		Child c = new Child();
		
		
		p.makeEgg();
		// 상속을 사용했기 때문에 부모 클래스가 가지고 있는 메소드를 재사용하는 것이 가능하다!
		c.makeEgg();
		// 메소드 오버라이딩을 하게 되면 오버라이딩한 메소드를 호출!
		c.makeBab();
		// 자식 클래스에만 선언된 메소드는 부모 객체는 사용할 수 없다!
		
		
		//  상속의 특징 3가지
		// 1. 다중상속이 불가능하다.
		// 2. 상속의 횟수에 제한이 없다.
		// 3. 모든 클래스는 Object(최상위클래스) 상속받는다.
		
		
		// 객체의 Casting(형변환)
		// Reference Type의 형변환은 반드시 상속이 전제되어 있어야한다!
		// --> 객체 내 필드, 메소드의 접근권한을 기준으로 강제 vs 자동 결정
		
		// 1) UpCasting(업캐스팅)
		//    : 자식(서브, 하위) 클래스가 부모(슈퍼, 상위) 클래스 타입으로
		//      자동 형변환 되는 것
		Parents p2 = new Child();
		p2.makeEgg(); // 모양은 Parents인데 가져오는 것은 Child에서 가져왔다
		// 객체 내 모든 필드와 메소드에 접근 할 수 있는 게 아니라
		// 상위 클래스의 필드와 메소드에만 접근 가능하다!
		// 오버라이딩 된 메소드에 한해서는 하위 클래스에 있는 메소드를 사용한다.
		// --> 그래서 egg는 Child에도 있기에 가져올 때 Child부터 보기 때문에 Child에서 가져왔다. 
		
		
		// 2) DownCasting(다운캐스팅)
		//    : 부모 클래스가 자식 클래스로 강제 형변환
		
		// Child c2 = (Child)new Parents();  --> 불가능
		// 강제형변환은 빨간줄이 뜨면 소괄호()해줘서 형변환 시키기
		// Parents를 가지고 Child를 만들 수 없다고 오류남 (exception - 예외상황)
		// Child는 메소드를 김치, 에그, 밥 셋 다 쓸 수 있는데 밥을 채울 수가 없다.
		
		// Parents 설계만 가지고는 Child 객체를 만들 수 없다!!
		// : 업캐스팅 된 객체를 다시 본래의 자료형으로 되돌릴 때 사용
		Child c2 = (Child)p2; // p2를 가져와서 강제로 되돌려놓는다는 뜻
	    c2.makeBab();
		c2.makeKimchi();
		
		
		
		// 4.15 상속복습
		// 상속 : 기존 클래스(슈퍼, 상위, 부모)가 가지고 있는 필드, 메소드를 
		// 그대로 물려받아서 새로운 클래스(서브, 하위, 자식)가 사용 가능하다.
		// 재사용 + 확장
		// class 서브클래스 extends 슈퍼클래스
		// extends : 확장하다, 연결하다
		//    상속의 특징 
		// 1) 다중 상속 불가능
		// 2) 상속 횟수 제한 없다
		// 3) 모든 클래스는 Object(최상위클래스) 상속
		// 메소드 오버라이딩(재정의) : 부모 클래스가 가지고 있는 메소드 틀(이름, 매개변수, 리턴타입)을
		// 그대로 가지고와서 {} 로직만 새롭게 작성
		// => 상속이 전제되어 있어야한다!
		// 객체 형변환(casting) : 객체 내에 있는 필드, 메소드 접근권한
		// 1) 업캐스팅  : 자식클래스가 부모클래스로 자동 형변환
		//     => Parents p = new Child();  자식클래스를 만들지만 틀은 부모클래스!
		// 2) 다운캐스팅 : 부모클래스가 자식클래스로 강제 형변환
		//     => 이미 업캐스팅 된 객체를 가져와서 자신의 원래 자료형을 되돌릴 때 사용! 
		
		
		
		
	}

}
